import json
import os
from datetime import timedelta
from http.server import BaseHTTPRequestHandler, HTTPServer
from time import mktime
from urllib.parse import parse_qs, urlencode, urlparse
from wsgiref.handlers import format_date_time

from requests.exceptions import HTTPError

from create_ical import return_calendar_content
from get_weather_data import HTTPErrorWithContent, generate_weather_data


def flat_opts(d):
    for key, value in d.items():
        if isinstance(value, list) and len(value) == 1:
            d[key] = value[0]
    return d


def bool_eval(value):
    true_values = {"y", "yes", "t", "true", "on", "1", 1, True}
    return str(value).lower() in true_values


class SharedCalendarServer(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed_url = urlparse(self.path)
        path = parsed_url.path
        query_components = parse_qs(parsed_url.query)

        if path == "/weather":

            weather_opts = {
                "zip_code": query_components.get("zip", None),
                "metric": query_components.get("metric", False),
                "api_key": query_components.get("api_key", os.environ.get("ACCUWEATHER_API_KEY")),
                "show_location": query_components.get("show_location", False),
            }

            weather_opts = flat_opts(weather_opts)

            weather_opts["metric"] = bool_eval(weather_opts["metric"])
            weather_opts["show_location"] = bool_eval(weather_opts["show_location"])

            try:
                weather_data = generate_weather_data(**weather_opts)

                http_response = return_calendar_content(weather_data)

                last_update_dt = weather_data["LastUpdated"]
                expires_dt = last_update_dt + timedelta(hours=1)
                lu_http_date = format_date_time(mktime(last_update_dt.timetuple()))
                expr_http_date = format_date_time(mktime(expires_dt.timetuple()))

                self.send_response(200)
                self.send_header("Content-Type", "text/calendar; charset=utf-8")
                self.send_header("Last-Modified", lu_http_date)
                self.send_header("Expires", expr_http_date)
                self.send_header("Cache-Control", "public, max-age=3600, stale-if-error=86400")
                self.end_headers()
                self.wfile.write(http_response)
            except HTTPErrorWithContent as http_err:
                self.send_response(http_err.status_code)

                if isinstance(http_err.content, dict):
                    self.send_header("Content-Type", "application/json; charset=utf-8")
                    self.end_headers()
                    self.wfile.write(bytes(json.dumps(http_err.content), "utf-8"))
                else:
                    self.send_header("Content-Type", "text/plain; charset=utf-8")
                    self.end_headers()
                    self.wfile.write(bytes(http_err.content, "utf-8"))

            except HTTPError as http_err:
                self.send_response(http_err.args[0])  # Use the status code from the exception
                self.send_header("Content-Type", "text/plain; charset=utf-8")
                self.end_headers()
                self.wfile.write(bytes(f"HTTP {http_err.args[0]}:\nGenerated by request {self.path}", "utf-8"))
            except Exception as e:
                print(f"Exception type: {type(e).__name__}, Message: {str(e)}")
                self.send_response(500)
                self.send_header("Content-Type", "text/plain; charset=utf-8")
                self.end_headers()
                self.wfile.write(bytes(f"HTTP 500:\nUnhandled server exception for request: {self.path}", "utf-8"))

        elif path == "/link":
            self.send_response(200)
            self.send_header("Content-Type", "text/html; charset=utf-8")
            self.end_headers()

            html = f"""
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
            </head>
            <body>
                <a href="/weather?{urlencode(query_components, doseq=True)}">Link to iCalendar</a>
            </body>
            </html>
            """

            self.wfile.write(bytes(html, "utf-8"))

        elif path == "/":
            self.send_response(200)
            self.send_header("Content-Type", "text/html; charset=utf-8")
            self.end_headers()

            html = """
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Weather to iCalendar</title>
            </head>
            <body>
                <form action="/link" method="get">
                    Accuweather API Key: <input type="text" name="api_key"><br>
                    Zip Code: <input type="text" name="zip" pattern="\\d{5}" inputmode="numeric" required><br>
                    Units: <br>
                    <input type="radio" id="imperial" name="metric" value="false" checked>
                    <label for="imperial">Imperial</label><br>
                    <input type="radio" id="metric" name="metric" value="true">
                    <label for="metric">Metric</label><br>
                    Show Location: <br>
                    <input type="radio" id="yes" name="show_location" value="true">
                    <label for="yes">Yes</label><br>
                    <input type="radio" id="no" name="show_location" value="false" checked>
                    <label for="no">No</label><br>
                    <input type="submit" value="Submit">
                </form>
            </body>
            </html>
            """

            self.wfile.write(bytes(html, "utf-8"))
        elif path == "/favicon.ico":
            self.send_response(200)
            self.send_header("Content-Type", "image/x-icon")
            self.end_headers()
        else:
            self.send_response(404)
            self.send_header("Content-Type", "text/plain; charset=utf-8")
            self.end_headers()
            self.wfile.write(bytes(f"Invalid request: {self.path}", "utf-8"))

    def do_HEAD(self):
        self.send_response(200)
        self.send_header("Content-Type", "text/calendar; charset=utf-8")
        self.end_headers()


if __name__ == "__main__":
    if os.getenv("ACCUWEATHER_API_KEY"):
        print("Loaded ACCUWEATHER_API_KEY environment variable")

    server_port = os.getenv("PORT", "8080")
    server_address = ("", int(server_port))
    webServer = HTTPServer(server_address, SharedCalendarServer)
    print(f"Server started on port {server_port}")

    try:
        webServer.serve_forever()
    except KeyboardInterrupt:
        pass

    webServer.server_close()
    print("Server stopped.")
